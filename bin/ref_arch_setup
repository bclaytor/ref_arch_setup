#!/usr/bin/env ruby
STDOUT.sync

require "rubygems" unless defined?(Gem)
require "ref_arch_setup"
require "optparse"

available_commands = %w[install]

available_subcommands = %w[generate-pe-conf bootstrap infra-agent-install configure]

@options = {}
# options["some_option"] = "some value"  #to set a default value

global = OptionParser.new do |opt|
  opt.banner = <<-BANNER
  Usage: ref_arch_setup <command> [subcommand] [options]

  Available Commands:

    install                      - Install a bootstrapped PE on target_host
    install generate-pe-conf     - Generates a pe.conf for the install
    install bootstap             - Installs a bare bones PE on the target_host
    install infra-agent-install  - Installs agents on all infrastructure nodes
    install configure            - Configures infrastructure nodes to ref arch settings

  Available Options:

BANNER
  opt.on("-h", "--help", "Prints this help") do
    puts opt
    exit
  end
  opt.on("-v", "--version", "Show currently running version of ref_arch_setup") do
    puts RefArchSetup::Version::STRING
    exit 0
  end
end

def install_global_opts(opt)
  opt.on("--user value", "username for bolt to use to connect to target hosts") do |value|
    @options["user"] = value
  end
  opt.on("--password value", "passworf for bolt to use to connect to target hosts") do |value|
    @options["password"] = value
  end
  opt.on("--private-key value", "private key for bolt to use to connect to target hosts") do |value|
    @options["private_key"] = value
  end
end

def install_generate_opts(opt)
  opt.on("--primary-master value", "hostname of primary master") do |value|
    @options["primary_master"] = value
  end
  opt.on("--pe-version value", "PE version to choose base pe.conf for") do |value|
    @options["pe_version"] = value
  end
  opt.on("--console-password value", "password for the PE console") do |value|
    @options["console_password"] = value
  end
end

def install_bootstrap(opt)
  # TODO: remove primary master once we get implement getting the host from the pe.conf
  opt.on("--primary-master value", "hostname of primary master") do |value|
    @options["primary_master"] = value
  end
  opt.on("--pe-tarball value", "Path to PE tarball") do |value|
    @options["pe_tarball"] = value
  end
  opt.on("--pe-version value", "PE version to configure to be installed") do |value|
    @options["pe_version"] = value
  end
  opt.on("--pe-conf value", "Path to pe.conf file") do |value|
    @options["pe_conf"] = value
  end
end

def install_infra_agent_install(opt)
  opt.on("--pe-conf value", "Path to pe.conf file") do |value|
    @options["pe_conf"] = value
  end
end

def install_configure(opt)
  opt.on("--pe-conf value", "Path to pe.conf file") do |value|
    @options["pe_conf"] = value
  end
end

def install_opts(opt)
  install_global_opts(opt)
  install_generate_opts(opt)
  install_bootstrap(opt)
  install_infra_agent_install(opt)
  install_configure(opt)
end

commands = {
  "install" => OptionParser.new do |opt|
    opt.banner = "Usage: ref_arch_setup install [options]"
    install_opts(opt)
  end
}

subcommands = {
  "generate-pe-conf" => OptionParser.new do |opt|
    opt.banner = "Usage: ref_arch_setup install generate-pe-conf [options]"
    install_global_opts(opt)
    install_generate_opts(opt)
  end,
  "bootstrap" => OptionParser.new do |opt|
    opt.banner = "Usage: ref_arch_setup install bootstrap [options]"
    install_global_opts(opt)
    install_bootstrap(opt)
  end,
  "infra-agent-install" => OptionParser.new do |opt|
    opt.banner = "Usage: ref_arch_setup install infra-agent-install [options]"
    install_global_opts(opt)
    install_infra_agent_install(opt)
  end,
  "configure" => OptionParser.new do |opt|
    opt.banner = "Usage: ref_arch_setup install configure [options]"
    install_global_opts(opt)
    install_configure(opt)
  end
}

global.order!(ARGV)
command_string = ARGV[0]
subcommand_string = ARGV[1]

if command_string.nil?
  puts global.help
  exit 0
end

unless available_commands.include?(command_string)
  puts "# ERROR, #{command_string} is not an available command"
  puts
  puts global.help
  exit 1
end

if subcommand_string !~ /^[a-zA-Z]/
  commands[command_string].parse!
  cli = RefArchSetup::CLI.new(@options)
  cli.send(command_string)
else
  unless available_subcommands.include?(subcommand_string)
    puts "# ERROR, #{subcommand_string} is not an available subcommand of #{command_string}"
    puts
    puts global.help
    exit 1
  end
  subcommands[subcommand_string].parse!
  cli = RefArchSetup::CLI.new(@options)
  cli.run(command_string, subcommand_string)
end
